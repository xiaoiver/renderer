import { Format, PrimitiveTopology } from '@antv/g-device-api';
import { chunk, flatten } from 'lodash-es';
import { Box } from './Box';
import { Vec3 } from '../math';
import { Aabb } from '../components/primitive/Aabb';

/**
 *
 */
class MeshVertexAttribute {
  constructor(
    /**
     * The friendly name of the vertex attribute.
     */
    public name: string,
    /**
     * The _unique_ id of the vertex attribute.
     * This will also determine sort ordering when generating vertex buffers.
     * Built-in / standard attributes will use "close to zero" indices.
     * When in doubt, use a random / very large usize to avoid conflicts.
     */
    public id: number,
    /**
     * The format of the vertex attribute.
     */
    public format: Format,
  ) {}
}

/**
 * A 3D object made out of vertices representing triangles, lines, or points,
 * with "attribute" values for each vertex.
 *
 * Meshes can be automatically generated by a bevy `AssetLoader` (generally by loading a `Gltf` file),
 * or by converting a primitive [`shape`](crate::mesh::shape) using [`into`](std::convert::Into).
 * It is also possible to create one manually.
 * They can be edited after creation.
 *
 * Meshes can be rendered with a `Material`, like `StandardMaterial` in `PbrBundle`
 * or `ColorMaterial` in `ColorMesh2dBundle`.
 *
 * A [`Mesh`] in Bevy is equivalent to a "primitive" in the glTF format, for a
 * glTF Mesh representation, see `GltfMesh`.
 *
 * ## Manual creation
 *
 * The following function will construct a flat mesh, to be rendered with a
 * `StandardMaterial` or `ColorMaterial`:
 *
 * @example
 * ```ts
 * import { Mesh } from 'renderer';
 * function create_simple_parallelogram(): Mesh {
 *     // Create a new mesh using a triangle list topology, where each set of 3 vertices composes a triangle.
 *     new Mesh(PrimitiveTopology.TRIANGLES)
 *         // Add 4 vertices, each with its own position attribute (coordinate in
 *         // 3D space), for each of the corners of the parallelogram.
 *         .with_inserted_attribute(
 *             Mesh.ATTRIBUTE_POSITION,
 *             [[0.0, 0.0, 0.0], [1.0, 2.0, 0.0], [2.0, 2.0, 0.0], [1.0, 0.0, 0.0]]
 *         )
 *         // Assign a UV coordinate to each vertex.
 *         .with_inserted_attribute(
 *             Mesh.ATTRIBUTE_UV_0,
 *             [[0.0, 1.0], [0.5, 0.0], [1.0, 0.0], [0.5, 1.0]]
 *         )
 *         // Assign normals (everything points outwards)
 *         .with_inserted_attribute(
 *             Mesh.ATTRIBUTE_NORMAL,
 *             [[0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0]]
 *         )
 *         // After defining all the vertices and their attributes, build each triangle using the
 *         // indices of the vertices that make it up in a counter-clockwise order.
 *         .with_indices([
 *             // First triangle
 *             0, 3, 1,
 *             // Second triangle
 *             1, 3, 2
 *         ])
 * }
 * ```
 *
 * You can see how it looks like [here](https://github.com/bevyengine/bevy/blob/main/assets/docs/Mesh.png),
 * used in a `PbrBundle` with a square bevy logo texture, with added axis, points,
 * lines and text for clarity.
 *
 * ## Other examples
 *
 * For further visualization, explanation, and examples, see the built-in Bevy examples,
 * and the [implementation of the built-in shapes](https://github.com/bevyengine/bevy/tree/main/crates/bevy_render/src/mesh/shape).
 * In particular, [generate_custom_mesh](https://github.com/bevyengine/bevy/blob/main/examples/3d/generate_custom_mesh.rs)
 * teaches you to access modify a Mesh's attributes after creating it.
 *
 * ## Common points of confusion
 *
 * - UV maps in Bevy start at the top-left, see [`ATTRIBUTE_UV_0`](Mesh::ATTRIBUTE_UV_0),
 * other APIs can have other conventions, `OpenGL` starts at bottom-left.
 * - It is possible and sometimes useful for multiple vertices to have the same
 * [position attribute](Mesh::ATTRIBUTE_POSITION) value,
 * it's a common technique in 3D modelling for complex UV mapping or other calculations.
 *
 * ## Use with `StandardMaterial`
 *
 * To render correctly with `StandardMaterial`, a mesh needs to have properly defined:
 * - [`UVs`](Mesh::ATTRIBUTE_UV_0): Bevy needs to know how to map a texture onto the mesh
 * (also true for `ColorMaterial`).
 * - [`Normals`](Mesh::ATTRIBUTE_NORMAL): Bevy needs to know how light interacts with your mesh.
 * [0.0, 0.0, 1.0] is very common for simple flat meshes on the XY plane,
 * because simple meshes are smooth and they don't require complex light calculations.
 * - Vertex winding order: by default, `StandardMaterial.cull_mode` is [`Some(Face::Back)`](crate::render_resource::Face),
 * which means that Bevy would *only* render the "front" of each triangle, which
 * is the side of the triangle from where the vertices appear in a *counter-clockwise* order.
 *
 * TODO: allow values to be unloaded after been submitting to the GPU to conserve memory
 */
export class Mesh {
  /**
   * Where the vertex is located in space.
   */
  static ATTRIBUTE_POSITION = new MeshVertexAttribute(
    'Vertex_Position',
    0,
    Format.F32_RGB,
  );

  /**
   * The direction the vertex normal is facing in.
   */
  static ATTRIBUTE_NORMAL = new MeshVertexAttribute(
    'Vertex_Normal',
    1,
    Format.F32_RGB,
  );

  /**
   * Texture coordinates for the vertex.
   *
   * Values are generally between 0. and 1., with `StandardMaterial` and `ColorMaterial`
   * `[0.,0.]` is the top left of the texture, and [1.,1.] the bottom-right.
   * You usually want to only use values in that range, values outside will be
   * clamped per pixel not for the vertex, "stretching" the borders of the texture.
   * This behavior can be useful in some cases, usually when the borders have only
   * one color, for example a logo, and you want to "extend" those borders.
   */
  static ATTRIBUTE_UV_0 = new MeshVertexAttribute(
    'Vertex_Uv',
    2,
    Format.F32_RG,
  );

  /**
   * Alternate texture coordinates for the vertex.
   *
   * Typically, these are used for lightmaps, textures that provide
   * precomputed illumination.
   */
  static ATTRIBUTE_UV_1 = new MeshVertexAttribute(
    'Vertex_Uv_1',
    3,
    Format.F32_RG,
  );

  /**
   * The direction of the vertex tangent.
   * Usually generated with [`generate_tangents`](Mesh::generate_tangents) or
   * [`with_generated_tangents`](Mesh::with_generated_tangents).
   */
  static ATTRIBUTE_TANGENT = new MeshVertexAttribute(
    'Vertex_Tangent',
    4,
    Format.F32_RGBA,
  );

  /**
   * Per vertex coloring.
   */
  static ATTRIBUTE_COLOR = new MeshVertexAttribute(
    'Vertex_Color',
    5,
    Format.F32_RGBA,
  );

  /**
   * Per vertex joint transform matrix weight.
   */
  static ATTRIBUTE_JOINT_WEIGHT = new MeshVertexAttribute(
    'Vertex_JointWeight',
    6,
    Format.F32_RGBA,
  );

  /**
   * Per vertex joint transform matrix index
   */
  static ATTRIBUTE_JOINT_INDEX = new MeshVertexAttribute(
    'Vertex_JointIndex',
    7,
    Format.U16_RGBA_5551,
  );

  static from(sp: Box) {
    const vertices = [
      // Front
      [
        [sp.min_x, sp.min_y, sp.max_z],
        [0, 0, 1.0],
        [0, 0],
      ],
      [
        [sp.max_x, sp.min_y, sp.max_z],
        [0, 0, 1.0],
        [1.0, 0],
      ],
      [
        [sp.max_x, sp.max_y, sp.max_z],
        [0, 0, 1.0],
        [1.0, 1.0],
      ],
      [
        [sp.min_x, sp.max_y, sp.max_z],
        [0, 0, 1.0],
        [0, 1.0],
      ],
      // Back
      [
        [sp.min_x, sp.max_y, sp.min_z],
        [0, 0, -1.0],
        [1.0, 0],
      ],
      [
        [sp.max_x, sp.max_y, sp.min_z],
        [0, 0, -1.0],
        [0, 0],
      ],
      [
        [sp.max_x, sp.min_y, sp.min_z],
        [0, 0, -1.0],
        [0, 1.0],
      ],
      [
        [sp.min_x, sp.min_y, sp.min_z],
        [0, 0, -1.0],
        [1.0, 1.0],
      ],
      // Right
      [
        [sp.max_x, sp.min_y, sp.min_z],
        [1.0, 0, 0],
        [0, 0],
      ],
      [
        [sp.max_x, sp.max_y, sp.min_z],
        [1.0, 0, 0],
        [1.0, 0],
      ],
      [
        [sp.max_x, sp.max_y, sp.max_z],
        [1.0, 0, 0],
        [1.0, 1.0],
      ],
      [
        [sp.max_x, sp.min_y, sp.max_z],
        [1.0, 0, 0],
        [0, 1.0],
      ],
      // Left
      [
        [sp.min_x, sp.min_y, sp.max_z],
        [-1.0, 0, 0],
        [1.0, 0],
      ],
      [
        [sp.min_x, sp.max_y, sp.max_z],
        [-1.0, 0, 0],
        [0, 0],
      ],
      [
        [sp.min_x, sp.max_y, sp.min_z],
        [-1.0, 0, 0],
        [0, 1.0],
      ],
      [
        [sp.min_x, sp.min_y, sp.min_z],
        [-1.0, 0, 0],
        [1.0, 1.0],
      ],
      // Top
      [
        [sp.max_x, sp.max_y, sp.min_z],
        [0, 1.0, 0],
        [1.0, 0],
      ],
      [
        [sp.min_x, sp.max_y, sp.min_z],
        [0, 1.0, 0],
        [0, 0],
      ],
      [
        [sp.min_x, sp.max_y, sp.max_z],
        [0, 1.0, 0],
        [0, 1.0],
      ],
      [
        [sp.max_x, sp.max_y, sp.max_z],
        [0, 1.0, 0],
        [1.0, 1.0],
      ],
      // Bottom
      [
        [sp.max_x, sp.min_y, sp.max_z],
        [0, -1.0, 0],
        [0, 0],
      ],
      [
        [sp.min_x, sp.min_y, sp.max_z],
        [0, -1.0, 0],
        [1.0, 0],
      ],
      [
        [sp.min_x, sp.min_y, sp.min_z],
        [0, -1.0, 0],
        [1.0, 1.0],
      ],
      [
        [sp.max_x, sp.min_y, sp.min_z],
        [0, -1.0, 0],
        [0, 1.0],
      ],
    ];

    const positions = vertices.map(([position, n, uv]) => position);
    const normals = vertices.map(([position, n, uv]) => n);
    const uvs = vertices.map(([position, n, uv]) => uv);

    const indices = [
      0,
      1,
      2,
      2,
      3,
      0, // front
      4,
      5,
      6,
      6,
      7,
      4, // back
      8,
      9,
      10,
      10,
      11,
      8, // right
      12,
      13,
      14,
      14,
      15,
      12, // left
      16,
      17,
      18,
      18,
      19,
      16, // top
      20,
      21,
      22,
      22,
      23,
      20, // bottom
    ];

    return new Mesh(PrimitiveTopology.TRIANGLES)
      .with_inserted_attribute(Mesh.ATTRIBUTE_POSITION, positions)
      .with_inserted_attribute(Mesh.ATTRIBUTE_NORMAL, normals)
      .with_inserted_attribute(Mesh.ATTRIBUTE_UV_0, uvs)
      .with_indices(indices);
  }

  attributes: [MeshVertexAttribute, number[][]][] = [];

  /**
   * The vertex `indices` of the mesh.
   */
  indices: number[];

  /**
   * Construct a new mesh. You need to provide a [`PrimitiveTopology`] so that the
   * renderer knows how to treat the vertex data.
   * Most of the time this will be [`PrimitiveTopology.TRIANGLES`].
   */
  constructor(public primitive_topology: PrimitiveTopology) {}

  /**
   * Consumes the mesh and returns a mesh with data set for a vertex attribute (position, normal etc.).
   * The name will often be one of the associated constants such as [`Mesh::ATTRIBUTE_POSITION`].
   *
   * (Alternatively, you can use [`Mesh::insert_attribute`] to mutate an existing mesh in-place)
   */
  with_inserted_attribute(attribute: MeshVertexAttribute, value: number[][]) {
    this.insert_attribute(attribute, value);
    return this;
  }

  /**
   * Sets the data for a vertex attribute (position, normal etc.).
   * The name will often be one of the associated constants such as [`Mesh::ATTRIBUTE_POSITION`].
   */
  insert_attribute(attribute: MeshVertexAttribute, value: number[][]) {
    if (this.contains_attribute(attribute)) {
      this.remove_attribute(attribute);
    }

    // if (attribute.id == Mesh.ATTRIBUTE_JOINT_WEIGHT.id) {
    // }

    this.attributes.push([attribute, value]);
  }

  /**
   * Consumes the mesh and returns a mesh without the data for a vertex attribute
   */
  with_removed_attribute(attribute: MeshVertexAttribute) {
    this.remove_attribute(attribute);
    return this;
  }

  /**
   * Removes the data for a vertex attribute
   */
  remove_attribute(attribute: MeshVertexAttribute) {
    const index = this.attributes.findIndex(([a, _]) => a.id === attribute.id);
    const data = this.attributes[index][1];
    this.attributes.splice(index, 1);
    return data;
  }

  /**
   * Retrieves the data currently set to the vertex attribute with the specified `name`.
   */
  contains_attribute(attribute: MeshVertexAttribute) {
    return this.attributes.some(([a, _]) => a.id === attribute.id);
  }

  /**
   * Retrieves the data currently set to the vertex attribute with the specified `name`.
   */
  attribute(attribute: MeshVertexAttribute) {
    return this.attributes.find(([a, _]) => a.name === attribute.name)[1];
  }

  /**
   * Consumes the mesh and returns a mesh with the given vertex indices.
   * They describe how triangles are constructed out of the vertex attributes
   * and are therefore only useful for the [`PrimitiveTopology`] variants that use triangles.
   * (Alternatively, you can use [`Mesh::set_indices`] to mutate an existing mesh in-place)
   */
  with_indices(indices: number[]) {
    this.set_indices(indices);
    return this;
  }

  /**
   * Sets the vertex indices of the mesh. They describe how triangles are constructed out of the
   * vertex attributes and are therefore only useful for the [`PrimitiveTopology`] variants
   * that use triangles.
   */
  set_indices(indices: number[]) {
    this.indices = indices;
  }

  /**
   * Counts all vertices of the mesh.
   * If the attributes have different vertex counts, the smallest is returned.
   */
  count_vertices() {
    let vertex_count = 0;
    this.attributes.forEach(([attribute, value]) => {
      let attribute_len = value.length;
      if (vertex_count) {
        if (attribute_len !== vertex_count) {
          console.warn(
            `${attribute.name} has a different vertex count (${attribute_len}) than other attributes (${vertex_count}) in this mesh, all attributes will be truncated to match the smallest.`,
          );

          vertex_count = Math.min(attribute_len, vertex_count);
        }
      } else {
        vertex_count = attribute_len;
      }
    });
    return vertex_count;
  }

  /**
   * Duplicates the vertex attributes so that no vertices are shared.
   *
   * This can dramatically increase the vertex count, so make sure this is what you want.
   * Does nothing if no [Indices] are set.
   */
  duplicate_vertices() {
    const duplicate = (values: number[][], indices: number[]) => {
      return indices.map((i) => values[i]);
    };

    this.attributes.forEach((pair) => {
      const [_, data] = pair;
      if (this.indices) {
        pair[1] = duplicate(data, this.indices);
      }
    });
  }

  /**
   * Consumes the mesh and returns a mesh with no shared vertices.
   */
  with_duplicated_vertices() {
    this.duplicate_vertices();
    return this;
  }

  /**
   * Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of a mesh.
   */
  compute_flat_normals() {
    if (this.indices) {
      throw new Error(
        "`compute_flat_normals` can't work on indexed geometry. Consider calling `Mesh::duplicate_vertices`.",
      );
    }

    if (this.primitive_topology !== PrimitiveTopology.TRIANGLES) {
      throw new Error(
        '`compute_flat_normals` can only work on `TriangleList`s',
      );
    }

    const positions = this.attribute(Mesh.ATTRIBUTE_POSITION) as [
      number,
      number,
      number,
    ][];
    const normals = flatten(
      chunk(positions, 3).map(([a, b, c]) => {
        const normal = face_normal(a, b, c);
        return [normal, normal, normal];
      }),
    );

    this.insert_attribute(Mesh.ATTRIBUTE_NORMAL, normals);
  }

  with_computed_flat_normals() {
    this.compute_flat_normals();
    return this;
  }

  /**
   * Generate tangents for the mesh using the `mikktspace` algorithm.
   *
   * Sets the [`Mesh::ATTRIBUTE_TANGENT`] attribute if successful.
   * Requires a [`PrimitiveTopology::TriangleList`] topology
   * and the [`Mesh::ATTRIBUTE_POSITION`], [`Mesh::ATTRIBUTE_NORMAL`]
   * and [`Mesh::ATTRIBUTE_UV_0`] attributes set.
   */
  generate_tangents() {
    const tangents = generate_tangents_for_mesh(this);
    this.insert_attribute(Mesh.ATTRIBUTE_TANGENT, tangents);
  }

  /**
   * Consumes the mesh and returns a mesh with tangents generated using the `mikktspace` algorithm.
   * The resulting mesh will have the [`Mesh::ATTRIBUTE_TANGENT`] attribute if successful.
   *
   * (Alternatively, you can use [`Mesh::generate_tangents`] to mutate an existing mesh in-place)
   */
  with_generated_tangents() {
    this.generate_tangents();
    return this;
  }

  /**
   * Compute the Axis-Aligned Bounding Box of the mesh vertices in model space
   */
  compute_aabb() {
    const positions = this.attribute(Mesh.ATTRIBUTE_POSITION) as [
      number,
      number,
      number,
    ][];

    return Aabb.enclosing(positions);
  }
}

function face_normal(
  a: [number, number, number],
  b: [number, number, number],
  c: [number, number, number],
): [number, number, number] {
  const _a = new Vec3(a[0], a[1], a[2]);
  const _b = new Vec3(b[0], b[1], b[2]);
  const _c = new Vec3(c[0], c[1], c[2]);
  const normal = _b.sub(_a).cross(_c.sub(_a)).normalize();
  return [normal.x, normal.y, normal.z];
}

function generate_tangents_for_mesh(mesh: Mesh) {
  if (mesh.primitive_topology !== PrimitiveTopology.TRIANGLES) {
    throw new Error(`Unsupported topology when generating tangents`);
  }
  const positions = mesh.attribute(Mesh.ATTRIBUTE_POSITION);
  const normals = mesh.attribute(Mesh.ATTRIBUTE_NORMAL);
  const uvs = mesh.attribute(Mesh.ATTRIBUTE_UV_0);

  const len = positions.length;
  const tangents = new Array(len).fill([0, 0, 0, 0]);

  // const mikktspace_mesh: MikktspaceGeometryHelper = {
  //   indices: mesh.indices,
  //   positions,
  //   normals,
  //   uvs,
  //   tangents,
  // };
  return [];
}
